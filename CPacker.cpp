#include "pch.h"
#include "CPacker.h"
#include <compressapi.h>
#pragma comment (lib, "Cabinet.lib")

bool CPacker::Pack(CString strOriginFileName, CString strTargetFileName)
{
    // Parse PE
    if (!ParsePe(strOriginFileName))
    {
        return false;
    }

    // compress sections data
    if (!GetUnpackCode())
    {
        return false;
    }

    // get unpack code
    if (!EncryptSecs())
    {
        return false;
    }

    // build New PE file
    // 1. Sections data
    if (!PrepareSecData())
    {
        return false;
    }


    // 2. section table/sec hdrs
    if (!PrepareSecHdrs())
    {
        return false;
    }


    // 3. New Headers
    if (!PrepareNewHdrs())
    {
        return false;
    }

    // write to new PE FILE
    if (!WriteNewPE(strTargetFileName))
    {
        return false;
    }




    return true;
}

DWORD CPacker::CalFAwithRVA(DWORD IN dwRVA)
{
    IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)m_pSrcPeBuf;
    DWORD dwPEHdrOffset = pDosHdr->e_lfanew;
    IMAGE_NT_HEADERS32* pNTHdr = (IMAGE_NT_HEADERS32*)(m_pSrcPeBuf + dwPEHdrOffset);
    IMAGE_OPTIONAL_HEADER32* pOptinalHdr = &pNTHdr->OptionalHeader;

    int nNumOfSections = pNTHdr->FileHeader.NumberOfSections;

    IMAGE_SECTION_HEADER* pSectionHdrStart = (IMAGE_SECTION_HEADER*)((char*)pOptinalHdr + pNTHdr->FileHeader.SizeOfOptionalHeader);

    //判断是否落在文件头
    if (dwRVA >= 0 && dwRVA < pOptinalHdr->SizeOfHeaders)
    {
        return dwRVA;
    }
    else
    {
        // 判断节表
        for (int i = 0; i < nNumOfSections; i++)
        {
            if (dwRVA >= pSectionHdrStart[i].VirtualAddress && dwRVA < pSectionHdrStart[i].VirtualAddress + pSectionHdrStart[i].SizeOfRawData)
            {
                auto res= dwRVA - pSectionHdrStart[i].VirtualAddress + pSectionHdrStart[i].PointerToRawData;
                return res;
            }
        }
    }


    return 0;
}

bool CPacker::ParsePe(CString strFileName)
{

    m_hFile = CreateFile(strFileName,           // open MYFILE.TXT 
        GENERIC_READ,              // open for reading 
        FILE_SHARE_READ,           // share for reading 
        NULL,                      // no security 
        OPEN_EXISTING,             // existing file only 
        FILE_ATTRIBUTE_NORMAL,     // normal file 
        NULL);                     // no attr. template 
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    m_hMap = CreateFileMapping(m_hFile,    // Current file handle. 
        NULL,                              // Default security. 
        PAGE_READONLY,                    // Read/write permission. 
        0,                                 // Max. object size. 
        0,                                 // Size of hFile. 
        NULL);            // Name of mapping object. 
    if (m_hMap == NULL)
    {
        return false;
    }

    m_pSrcPeBuf = (LPBYTE)MapViewOfFile(m_hMap, // Handle to mapping object. 
        FILE_MAP_READ,               // Read/write permission 
        0,                                 // Max. object size. 
        0,                                 // Size of hFile. 
        0);                                // Map entire file. 
    if (m_pSrcPeBuf == NULL)
    {
        return false;
    }

    //解析
    m_pDosHdr = (PIMAGE_DOS_HEADER)m_pSrcPeBuf;
    //check MZ
    m_pNtHdr = (PIMAGE_NT_HEADERS)(m_pSrcPeBuf + m_pDosHdr->e_lfanew);
    //check PE
    m_pSecHdr = (PIMAGE_SECTION_HEADER)((LPBYTE)&m_pNtHdr->OptionalHeader + m_pNtHdr->FileHeader.SizeOfOptionalHeader);

    m_pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)m_pSrcPeBuf + CalFAwithRVA(m_pNtHdr->OptionalHeader.DataDirectory[1].VirtualAddress));
    m_dwOriginImportTableSize = m_pNtHdr->OptionalHeader.DataDirectory[1].Size;
    // 保留原始导入表, 注意，这里需要数据目录里的Size是正常的
    m_pOriginImportTable = new BYTE[m_dwOriginImportTableSize]{ 0 };
    RtlCopyMemory(m_pOriginImportTable, m_pImportTable, m_dwOriginImportTableSize);



    /*
    while (pImport->Name!=0)
    {
        if (pImport->FirstThunk==0)
        {
            break;
        }

        //拿名字
        char *pszName = (char *)((DWORD)m_pSrcPeBuf + CalFAwithRVA(pImport->Name));

        m_vecImports.push_back({ pszName,{} });


        DWORD dwINTRVA = 0;
        if (pImport->OriginalFirstThunk==0)
        {
            dwINTRVA = pImport->FirstThunk;
        }
        else
        {
            dwINTRVA = pImport->OriginalFirstThunk;
        }

        DWORD* pINT = (DWORD*)((DWORD)m_pSrcPeBuf + CalFAwithRVA(dwINTRVA));
        while (*pINT!=0)
        {
            if ((*pINT)&0x80000000)
            {
                //序号导入
                m_vecImports.back().m_vecAPIs.push_back({ false,{}, WORD((*pINT) & 0x0000FFFF) });
            }
            else
            {
                //名字导入
                char* pszAPIName = (char*)((DWORD)m_pSrcPeBuf + CalFAwithRVA(*pINT) + 2);
                m_vecImports.back().m_vecAPIs.push_back({ true,pszAPIName, 0 });
            }

            pINT++;
        }



        pImport++;
    }*/

    



    m_dwFileAlign = m_pNtHdr->OptionalHeader.FileAlignment;
    m_dwSectionAlign = m_pNtHdr->OptionalHeader.SectionAlignment;

    m_dwFileSize = GetFileSize(m_hFile, NULL);
    m_dwSecsTotalSize = m_dwFileSize;

    return true;
}

bool CPacker::EncryptSecs()
{
    //申请加密后数据缓冲区
    m_pEncryptedBuf = new BYTE[m_dwFileSize]{0};
    m_dwEncryptedSize = m_dwFileSize;

    RtlCopyMemory(m_pEncryptedBuf, m_pSrcPeBuf, m_dwFileSize);
    // 抹掉导入表
    auto pDosHdr = (PIMAGE_DOS_HEADER)m_pEncryptedBuf;
    auto pNtHdr = (PIMAGE_NT_HEADERS)(m_pEncryptedBuf + pDosHdr->e_lfanew);
    auto dwImportFA = CalFAwithRVA(pNtHdr->OptionalHeader.DataDirectory[1].VirtualAddress);
    RtlZeroMemory(m_pEncryptedBuf+ dwImportFA,
        pNtHdr->OptionalHeader.DataDirectory[1].Size);

    for (size_t i = 0; i < m_dwEncryptedSize; i++)
    {
        m_pEncryptedBuf[i] ^= 0xAA; //简单的异或加密
    }
    
 
    return true;
}

bool CPacker::GetUnpackCode()
{
    static unsigned char arrUnpackCode[1184] = {
    0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x8D, 0x45, 0xF0, 0x53, 0x56, 0x57, 0x50, 0xE8, 0x7A, 0x00,
    0x00, 0x00, 0x59, 0x64, 0xA1, 0x18, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x30, 0x8B, 0x40, 0x0C, 0x8B,
    0x40, 0x0C, 0x8B, 0x40, 0x18, 0x8B, 0xD8, 0x8B, 0x53, 0x3C, 0x8D, 0x7B, 0x0C, 0x03, 0xD3, 0x0F,
    0xB7, 0x4A, 0x14, 0x8B, 0x54, 0x11, 0x4C, 0x03, 0xFA, 0x8B, 0x74, 0x1A, 0x04, 0x03, 0x3C, 0x1A,
    0x56, 0x57, 0xE8, 0x2B, 0x03, 0x00, 0x00, 0x8D, 0x45, 0xF0, 0x50, 0x8D, 0x04, 0x3E, 0x50, 0x53,
    0x57, 0xE8, 0x01, 0x01, 0x00, 0x00, 0x83, 0xC4, 0x18, 0x5F, 0x5E, 0x5B, 0xC9, 0xC3, 0x55, 0x8B,
    0xEC, 0x51, 0x51, 0x8B, 0x45, 0x08, 0x89, 0x45, 0xF9, 0x8B, 0x45, 0x0C, 0xC6, 0x45, 0xF8, 0x68,
    0x8B, 0x4D, 0xF8, 0xC6, 0x45, 0xFD, 0xC3, 0x89, 0x08, 0x66, 0x8B, 0x4D, 0xFC, 0x66, 0x89, 0x48,
    0x04, 0x8B, 0x4D, 0x10, 0xC7, 0x01, 0x06, 0x00, 0x00, 0x00, 0xC9, 0xC3, 0x55, 0x8B, 0xEC, 0x83,
    0xEC, 0x40, 0x33, 0xC0, 0xC7, 0x45, 0xF0, 0x4C, 0x6F, 0x61, 0x64, 0x56, 0x57, 0xC7, 0x45, 0xF4,
    0x4C, 0x69, 0x62, 0x72, 0xC7, 0x45, 0xF8, 0x61, 0x72, 0x79, 0x41, 0x88, 0x45, 0xFC, 0xC7, 0x45,
    0xD0, 0x47, 0x65, 0x74, 0x50, 0xC7, 0x45, 0xD4, 0x72, 0x6F, 0x63, 0x41, 0xC7, 0x45, 0xD8, 0x64,
    0x64, 0x72, 0x65, 0x66, 0xC7, 0x45, 0xDC, 0x73, 0x73, 0x88, 0x45, 0xDE, 0xC7, 0x45, 0xC0, 0x56,
    0x69, 0x72, 0x74, 0xC7, 0x45, 0xC4, 0x75, 0x61, 0x6C, 0x50, 0xC7, 0x45, 0xC8, 0x72, 0x6F, 0x74,
    0x65, 0x66, 0xC7, 0x45, 0xCC, 0x63, 0x74, 0x88, 0x45, 0xCE, 0xC7, 0x45, 0xE0, 0x56, 0x69, 0x72,
    0x74, 0xC7, 0x45, 0xE4, 0x75, 0x61, 0x6C, 0x41, 0xC7, 0x45, 0xE8, 0x6C, 0x6C, 0x6F, 0x63, 0x88,
    0x45, 0xEC, 0x64, 0xA1, 0x18, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x30, 0x8B, 0x40, 0x0C, 0x8B, 0x40,
    0x0C, 0x8B, 0x00, 0x8B, 0x00, 0x8B, 0x40, 0x18, 0x8B, 0xF8, 0x8D, 0x45, 0xF0, 0x50, 0x57, 0xE8,
    0x68, 0x02, 0x00, 0x00, 0x8B, 0x75, 0x08, 0x89, 0x06, 0x8D, 0x45, 0xD0, 0x50, 0x57, 0xE8, 0x59,
    0x02, 0x00, 0x00, 0x89, 0x46, 0x04, 0x8D, 0x45, 0xC0, 0x50, 0x57, 0xE8, 0x4C, 0x02, 0x00, 0x00,
    0x89, 0x46, 0x08, 0x8D, 0x45, 0xE0, 0x50, 0x57, 0xE8, 0x3F, 0x02, 0x00, 0x00, 0x83, 0xC4, 0x20,
    0x89, 0x46, 0x0C, 0x5F, 0x5E, 0xC9, 0xC3, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x3C, 0x8B, 0x45, 0x08,
    0x8D, 0x4D, 0xFC, 0x53, 0x56, 0x8B, 0x75, 0x0C, 0x8B, 0x58, 0x3C, 0x03, 0xD8, 0xC7, 0x45, 0xD8,
    0x5F, 0x61, 0x63, 0x6D, 0x57, 0x51, 0x6A, 0x04, 0x0F, 0xB7, 0x43, 0x14, 0x8D, 0x7B, 0x18, 0x83,
    0x65, 0xFC, 0x00, 0x03, 0xC7, 0xFF, 0x77, 0x3C, 0x89, 0x45, 0xE8, 0x8B, 0x45, 0x14, 0x56, 0xC7,
    0x45, 0xDC, 0x64, 0x6C, 0x6E, 0x00, 0x89, 0x7D, 0xF4, 0xFF, 0x50, 0x08, 0xFF, 0x77, 0x3C, 0xFF,
    0x75, 0x08, 0x56, 0xE8, 0xD3, 0x02, 0x00, 0x00, 0x83, 0xC4, 0x0C, 0x8D, 0x45, 0xFC, 0x50, 0xFF,
    0x75, 0xFC, 0x8B, 0x45, 0x14, 0xFF, 0x77, 0x3C, 0x56, 0xFF, 0x50, 0x08, 0x83, 0x65, 0xF8, 0x00,
    0x33, 0xC0, 0x66, 0x3B, 0x43, 0x06, 0x73, 0x2F, 0x8B, 0x7D, 0xE8, 0x83, 0xC7, 0x14, 0xFF, 0x77,
    0xFC, 0x8B, 0x07, 0x03, 0x45, 0x08, 0x50, 0x8B, 0x47, 0xF8, 0x03, 0xC6, 0x50, 0xE8, 0x99, 0x02,
    0x00, 0x00, 0x8B, 0x4D, 0xF8, 0x8D, 0x7F, 0x28, 0x0F, 0xB7, 0x43, 0x06, 0x83, 0xC4, 0x0C, 0x41,
    0x89, 0x4D, 0xF8, 0x3B, 0xC8, 0x72, 0xD7, 0x8B, 0x5D, 0x14, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x6A,
    0x40, 0x50, 0x50, 0x6A, 0x00, 0xFF, 0x53, 0x0C, 0x89, 0x45, 0xF8, 0x8D, 0x7D, 0xC4, 0x33, 0xC0,
    0x83, 0x65, 0xE8, 0x00, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0x8B, 0x7D, 0x10, 0xE9, 0xC5, 0x00, 0x00,
    0x00, 0x8B, 0x47, 0x0C, 0x85, 0xC0, 0x0F, 0x84, 0xD1, 0x00, 0x00, 0x00, 0x03, 0xC6, 0x50, 0xFF,
    0x13, 0x89, 0x45, 0xE4, 0x85, 0xC0, 0x0F, 0x84, 0x32, 0x01, 0x00, 0x00, 0x8B, 0x4F, 0x10, 0x85,
    0xC9, 0x0F, 0x84, 0xB6, 0x00, 0x00, 0x00, 0x8B, 0x17, 0x8D, 0x04, 0x31, 0x89, 0x45, 0xE0, 0x8D,
    0x3C, 0x32, 0x85, 0xD2, 0x75, 0x02, 0x8B, 0xF8, 0x83, 0x65, 0xF0, 0x00, 0x8B, 0x07, 0x85, 0xC0,
    0x74, 0x77, 0x83, 0x65, 0xEC, 0x00, 0xC6, 0x45, 0x0B, 0x00, 0x85, 0xC0, 0x79, 0x05, 0x0F, 0xB7,
    0xD8, 0xEB, 0x1C, 0x8D, 0x5E, 0x02, 0x03, 0xD8, 0x8D, 0x45, 0xD8, 0x6A, 0x08, 0x50, 0x53, 0xE8,
    0xC8, 0x01, 0x00, 0x00, 0x83, 0xC4, 0x0C, 0x85, 0xC0, 0x75, 0x04, 0xC6, 0x45, 0x0B, 0x01, 0x53,
    0x8B, 0x5D, 0x14, 0xFF, 0x75, 0xE4, 0xFF, 0x53, 0x04, 0x80, 0x7D, 0x0B, 0x00, 0x75, 0x1D, 0x83,
    0x65, 0x08, 0x00, 0x8D, 0x4D, 0x08, 0x51, 0xFF, 0x75, 0xF8, 0x50, 0xE8, 0xAE, 0xFD, 0xFF, 0xFF,
    0x8B, 0x4D, 0xF8, 0x83, 0xC4, 0x0C, 0x03, 0x4D, 0x08, 0x89, 0x4D, 0xF8, 0x8B, 0x4D, 0xEC, 0x8B,
    0x55, 0xE0, 0x89, 0x04, 0x11, 0x8B, 0x4D, 0xF0, 0x41, 0x89, 0x4D, 0xF0, 0xC1, 0xE1, 0x02, 0x89,
    0x4D, 0xEC, 0x8B, 0x04, 0x39, 0x85, 0xC0, 0x75, 0x8D, 0x8B, 0x45, 0xE8, 0x40, 0x6B, 0xF8, 0x14,
    0x89, 0x45, 0xE8, 0x03, 0x7D, 0x10, 0x6A, 0x14, 0x8D, 0x45, 0xC4, 0x50, 0x57, 0xE8, 0x5A, 0x01,
    0x00, 0x00, 0x83, 0xC4, 0x0C, 0x85, 0xC0, 0x0F, 0x85, 0x24, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xF4,
    0x33, 0xD2, 0x89, 0x55, 0x14, 0x8B, 0x88, 0x88, 0x00, 0x00, 0x00, 0x8B, 0x98, 0x8C, 0x00, 0x00,
    0x00, 0x03, 0xCE, 0x89, 0x5D, 0x08, 0x85, 0xDB, 0x74, 0x4A, 0x8B, 0x79, 0x04, 0x83, 0xEF, 0x08,
    0xD1, 0xEF, 0x6A, 0x00, 0x5B, 0x74, 0x2C, 0x0F, 0xB7, 0x54, 0x59, 0x08, 0xF7, 0xC2, 0x00, 0xF0,
    0x00, 0x00, 0x74, 0x17, 0x81, 0xE2, 0xFF, 0x0F, 0x00, 0x00, 0x8B, 0xC6, 0x03, 0xD6, 0x8B, 0x75,
    0xF4, 0x03, 0x11, 0x2B, 0x46, 0x1C, 0x01, 0x02, 0x8B, 0x75, 0x0C, 0x43, 0x3B, 0xDF, 0x72, 0xD7,
    0x8B, 0x55, 0x14, 0x03, 0x51, 0x04, 0x03, 0x49, 0x04, 0x89, 0x55, 0x14, 0x3B, 0x55, 0x08, 0x72,
    0xB9, 0x8B, 0x45, 0xF4, 0x8B, 0x40, 0x10, 0x03, 0xC6, 0x5F, 0x5E, 0x5B, 0xC9, 0xC3, 0x33, 0xC0,
    0xEB, 0xF7, 0x55, 0x8B, 0xEC, 0x8B, 0x45, 0x0C, 0x33, 0xC9, 0x85, 0xC0, 0x74, 0x0C, 0x8B, 0x55,
    0x08, 0x80, 0x34, 0x11, 0xAA, 0x41, 0x3B, 0xC8, 0x72, 0xF7, 0x5D, 0xC3, 0x55, 0x8B, 0xEC, 0x51,
    0x51, 0x53, 0x56, 0x8B, 0x75, 0x08, 0x33, 0xC9, 0x57, 0x8B, 0x46, 0x3C, 0x8B, 0x54, 0x30, 0x78,
    0x03, 0xD6, 0xF7, 0x45, 0x0C, 0x00, 0x00, 0xFF, 0xFF, 0x89, 0x55, 0xFC, 0x74, 0x6D, 0x8B, 0x42,
    0x20, 0x8B, 0xF9, 0x03, 0xC6, 0x89, 0x45, 0xF8, 0x39, 0x4A, 0x18, 0x76, 0x59, 0x8B, 0x04, 0xB8,
    0x8B, 0x5D, 0x0C, 0x03, 0xC6, 0x8A, 0x13, 0x3A, 0x10, 0x88, 0x55, 0x0B, 0x8B, 0x55, 0xFC, 0x75,
    0x22, 0x38, 0x4D, 0x0B, 0x74, 0x19, 0x8A, 0x53, 0x01, 0x3A, 0x50, 0x01, 0x88, 0x55, 0x0B, 0x8B,
    0x55, 0xFC, 0x75, 0x0F, 0x83, 0xC3, 0x02, 0x83, 0xC0, 0x02, 0x38, 0x4D, 0x0B, 0x75, 0xD6, 0x8B,
    0xC1, 0xEB, 0x05, 0x1B, 0xC0, 0x83, 0xC8, 0x01, 0x85, 0xC0, 0x74, 0x10, 0x8B, 0x45, 0xF8, 0x47,
    0x3B, 0x7A, 0x18, 0x72, 0xB8, 0x33, 0xC0, 0x5F, 0x5E, 0x5B, 0xC9, 0xC3, 0x8B, 0x42, 0x24, 0x8D,
    0x04, 0x78, 0x0F, 0xB7, 0x0C, 0x30, 0x3B, 0x7A, 0x18, 0xEB, 0x09, 0x8B, 0x4D, 0x0C, 0x2B, 0x4A,
    0x10, 0x3B, 0x4A, 0x14, 0x73, 0xDF, 0x8B, 0x42, 0x1C, 0x8D, 0x04, 0x88, 0x8B, 0x04, 0x30, 0x85,
    0xC0, 0x74, 0xD2, 0x03, 0xC6, 0xEB, 0xD0, 0x83, 0xEC, 0x04, 0x60, 0xE8, 0xC0, 0xFB, 0xFF, 0xFF,
    0x89, 0x44, 0x24, 0x20, 0x61, 0x83, 0xC4, 0x04, 0xFF, 0x64, 0x24, 0xFC, 0x55, 0x8B, 0xEC, 0x8B,
    0x4D, 0x10, 0x85, 0xC9, 0x75, 0x04, 0x33, 0xC0, 0x5D, 0xC3, 0x8B, 0x55, 0x0C, 0x56, 0x8B, 0x75,
    0x08, 0x83, 0xE9, 0x01, 0x74, 0x0A, 0x8A, 0x06, 0x3A, 0x02, 0x75, 0x04, 0x46, 0x42, 0xEB, 0xF1,
    0x0F, 0xB6, 0x06, 0x0F, 0xB6, 0x0A, 0x2B, 0xC1, 0x5E, 0x5D, 0xC3, 0x55, 0x8B, 0xEC, 0x8B, 0x45,
    0x08, 0x56, 0x8B, 0x75, 0x10, 0x85, 0xF6, 0x74, 0x14, 0x8B, 0x55, 0x0C, 0x57, 0x8B, 0xF8, 0x2B,
    0xFA, 0x8A, 0x0A, 0x88, 0x0C, 0x17, 0x42, 0x83, 0xEE, 0x01, 0x75, 0xF5, 0x5F, 0x5E, 0x5D, 0xC3
    };

    
    m_dwUnpackCodeSize = sizeof(arrUnpackCode);
    m_pUnpackCode = arrUnpackCode;
    m_dwUnpackCodeEPoffset = 0x437;
    return true;
}

bool CPacker::PrepareSecData()
{
    //计算对齐后的大小
    DWORD dwSize = sizeof(ConfigInfo) +
        m_dwUnpackCodeSize +
        m_dwEncryptedSize +
        m_dwOriginImportTableSize;

    m_dwSecDataSize = CalAlignment(dwSize, m_dwFileAlign);


    //申请缓冲区
    m_pSecData = new BYTE[m_dwSecDataSize]{ 0 };
    
    ConfigInfo ci = { m_dwUnpackCodeSize,m_dwEncryptedSize,m_dwSecsTotalSize };

    //拷贝
    RtlCopyMemory(m_pSecData, &ci, sizeof(ci));
    RtlCopyMemory(m_pSecData + sizeof(ci), m_pUnpackCode, m_dwUnpackCodeSize);
    RtlCopyMemory(m_pSecData + sizeof(ci) + m_dwUnpackCodeSize, m_pEncryptedBuf, m_dwEncryptedSize);
    RtlCopyMemory(m_pSecData + sizeof(ci) + m_dwUnpackCodeSize+ m_dwEncryptedSize, m_pOriginImportTable, m_dwOriginImportTableSize);


    return true;
}

bool CPacker::PrepareSecHdrs()
{
    // 第一个节为空节
    strcpy((char*)m_ArrSecHdrs[0].Name, ".empty");
    m_ArrSecHdrs[0].PointerToRawData = 0; //空节没有文件数据
    m_ArrSecHdrs[0].SizeOfRawData = 0;
    //与原PE第一个节位置一样
    m_ArrSecHdrs[0].VirtualAddress = m_pSecHdr->VirtualAddress;
    m_ArrSecHdrs[0].Misc.VirtualSize = m_pNtHdr->OptionalHeader.SizeOfImage - m_pSecHdr[0].VirtualAddress;
    m_ArrSecHdrs[0].Characteristics = 0xe0000000;



    //第二个节，代码数据节
    strcpy((char*)m_ArrSecHdrs[1].Name, ".data");
    //紧跟文件头后面
    m_ArrSecHdrs[1].PointerToRawData = m_pNtHdr->OptionalHeader.SizeOfHeaders;
    m_ArrSecHdrs[1].SizeOfRawData = m_dwSecDataSize;
    //内存，跟随第一个节 第一个节的地址+第一个节的大小
    m_ArrSecHdrs[1].VirtualAddress =
        m_ArrSecHdrs[0].VirtualAddress + CalAlignment(m_ArrSecHdrs[0].Misc.VirtualSize,m_dwSectionAlign);
    m_ArrSecHdrs[1].Misc.VirtualSize = m_dwSecDataSize;
    m_ArrSecHdrs[1].Characteristics = 0xe0000000;



    return true;
}

bool CPacker::PrepareNewHdrs()
{
    // 申请缓冲区
    m_dwNewHdrsSize = m_pNtHdr->OptionalHeader.SizeOfHeaders;
    m_pNewPeHdrs = new BYTE[m_dwNewHdrsSize];


    //复制原PE头
    RtlCopyMemory(m_pNewPeHdrs, m_pSrcPeBuf, m_dwNewHdrsSize);


    //修改字段
    auto pDosHdr = (PIMAGE_DOS_HEADER)m_pNewPeHdrs;
    auto pNtHdr = (PIMAGE_NT_HEADERS)(m_pNewPeHdrs + pDosHdr->e_lfanew);
    auto pSecHdr = (PIMAGE_SECTION_HEADER)((LPBYTE)&pNtHdr->OptionalHeader + pNtHdr->FileHeader.SizeOfOptionalHeader);

    pNtHdr->FileHeader.NumberOfSections = 2;
    //入口点为第二个节的起始+配置信息
    pNtHdr->OptionalHeader.AddressOfEntryPoint =
        m_ArrSecHdrs[1].VirtualAddress + sizeof(ConfigInfo) + m_dwUnpackCodeEPoffset;

    //修改sizeofimage,最后一个节的地址+大小
    pNtHdr->OptionalHeader.SizeOfImage = m_ArrSecHdrs[1].VirtualAddress +
        CalAlignment(m_ArrSecHdrs[1].Misc.VirtualSize, m_dwSectionAlign);

    //清除数据目录
    RtlZeroMemory(pNtHdr->OptionalHeader.DataDirectory, sizeof(pNtHdr->OptionalHeader.DataDirectory)* pNtHdr->OptionalHeader.NumberOfRvaAndSizes);

    //拷贝节表
    RtlCopyMemory(pSecHdr, m_ArrSecHdrs, sizeof(m_ArrSecHdrs));



    return true;
}

bool CPacker::WriteNewPE(CString strFileName)
{
    auto hFile = CreateFile(strFileName,           // open MYFILE.TXT 
        GENERIC_WRITE,              // open for reading 
        FILE_SHARE_READ,           // share for reading 
        NULL,                      // no security 
        CREATE_ALWAYS,             // existing file only 
        FILE_ATTRIBUTE_NORMAL,     // normal file 
        NULL);                     // no attr. template 
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    DWORD dwBytesWritten = 0;
    WriteFile(hFile, m_pNewPeHdrs, m_dwNewHdrsSize, &dwBytesWritten, NULL);
    WriteFile(hFile, m_pSecData, m_dwSecDataSize, &dwBytesWritten, NULL);

    CloseHandle(hFile);
    return true;



}
